#include <x86emu/x86Emulator.h>
#include <iostream>
#include <string.h>

using namespace std;
using namespace X86Emu;

#define MEMSIZE 0x1000

//char _1234[] = { 0x90, 0xfa, 0x90, 0xfb, 0x40, 0x48, 0xb8, 0x34, 0x12 };
//char _1234[] = { 0xb0, 0xab, 0xb4, 0x55, 0xf4 };    //MOV AL, 0xab  MOV AH, 0x55    HLT
//char _1234[] = { 0xb8, 0xab, 0x55, 0xf4 };  //MOV AX, 0x55ab    HLT
//char _1234[] = { 0x66, 0xb8, 0xab, 0x55, 0xab, 0x55, 0xf4 };  //MOV EAX, 0x55ab55ab    HLT
char movPushEAX[] = { 0x66, 0xb8, 0xab, 0x55, 0xab, 0x55, 0x66, 0x50, 0xf4 };   //MOV EAX, 0x55ab55ab   PUSH EAX    HLT
char movPushECX[] = { 0x66, 0xb9, 0xab, 0x55, 0xab, 0x55, 0x66, 0x51, 0xf4 };   //MOV ECX, 0x55ab55ab   PUSH ECX    HLT
char movPushEDX[] = { 0x66, 0xba, 0xab, 0x55, 0xab, 0x55, 0x66, 0x52, 0xf4 };   //MOV EDX, 0x55ab55ab   PUSH EDX    HLT
char movPushEBX[] = { 0x66, 0xbb, 0xab, 0x55, 0xab, 0x55, 0x66, 0x53, 0xf4 };   //MOV EBX, 0x55ab55ab   PUSH EBX    HLT

char movPushEBP[] = { 0x66, 0xbd, 0xab, 0x55, 0xab, 0x55, 0x66, 0x55, 0xf4 };   //MOV EBP, 0x55ab55ab   PUSH EBP    HLT
char movPushESI[] = { 0x66, 0xbe, 0xab, 0x55, 0xab, 0x55, 0x66, 0x56, 0xf4 };   //MOV ESI, 0x55ab55ab   PUSH ESI    HLT
char movPushEDI[] = { 0x66, 0xbf, 0xab, 0x55, 0xab, 0x55, 0x66, 0x57, 0xf4 };   //MOV EDI, 0x55ab55ab   PUSH EDI    HLT
char pushESP[] = { 0x66, 0x54, 0xf4 };                                          //PUSH ESP      HLT
char pushSP[] = { 0x54, 0xf4 };                                                 //PUSH SP       HLT

char movPushEAXPopEBX[] = { 0x66, 0xb8, 0xab, 0x55, 0xab, 0x55, 0x66, 0x50, 0x66, 0x5a, 0xf4 };   //MOV EAX, 0x55ab55ab   PUSH EAX    POP EDX     HLT

char jnoHlt[] = {0x71, 0x3, 0x90, 0x90, 0x90, 0xf4};   //JNO +3    NOP     NOP     NOP     HLT

char movEaxXCHGCX[] = {0x66, 0xb8, 0xab, 0x55, 0xab, 0x55, 0x66, 0x91, 0xf4}; //MOV EAX, 0x55ab55ab   EXCHG CX    HLT

char movEAXaddByteAL[] = { 0x66, 0xb8, 0xab, 0x55, 0xab, 0x55, 0x04, 0x10, 0xf4 };   //MOV EAX, 0x55ab55ab   ADD AL, 0x10   HLT

char alAddByte[] = { 0x04, 0x10, 0xf4 };    //ADD AL, 0x10      HLT
char axAddWord[] = { 0x05, 0x00, 0x10, 0xf4 };  //ADD AX, 0x1000    HLT
char eaxAddDword[] = { 0x66, 0x05, 0x00, 0x00, 0x00, 0x10, 0xf4 };  //ADD EAX, 0x10000000   HLT

char alOrByte[] = { 0x0c, 0x55, 0xf4 }; //OR AL, 0x55   HLT
char axOrWord[] = { 0x0d, 0x55, 0x55, 0xf4 };   //OR AX, 0x5555     HLT
char eaxOrDword[] = { 0x66, 0x0d, 0x55, 0x55, 0x55, 0x55, 0xf4 };   //OR EAX, 0x55555555    HLT

char alAdcByte[] = { 0x14, 0x10, 0xf4 };    //ADC AL, 0x10      HLT
char axAdcWord[] = { 0x15, 0x00, 0x10, 0xf4 };  //ADC AX, 0x1000    HLT
char eaxAdcDword[] = { 0x66, 0x15, 0x00, 0x00, 0x00, 0x10, 0xf4 };  //ADC EAX, 0x10000000   HLT

char alSbbByte[] = { 0x1c, 0x10, 0xf4 };    //SBB AL, 0x10      HLT
char axSbbWord[] = { 0x1d, 0x00, 0x10, 0xf4 };  //SBB AX, 0x1000    HLT
char eaxSbbDword[] = { 0x66, 0x1d, 0x00, 0x00, 0x00, 0x10, 0xf4 };  //SBB EAX, 0x10000000   HLT

char alAndByte[] = { 0xb0, 0x01, 0x24, 0x55, 0xf4 }; //MOV AL, 0x1  OR AL, 0x55   HLT
char axAndWord[] = { 0xb8, 0x01, 0x00, 0x25, 0x55, 0x55, 0xf4 };   //MOV AX, 0x1    OR AX, 0x5555     HLT
char eaxAndDword[] = { 0x66, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x66, 0x25, 0x55, 0x55, 0x55, 0x55, 0xf4 };   //MOV EAX, 0x1     OR EAX, 0x55555555    HLT

char lahf[] = { 0x9f, 0xf4 };   //SAHF  HLT

char aad[] = { 0xb8, 0x02, 0x00, 0xd5, 0x0a, 0xf4}; //MOV AX, 0x0002    AAD     HLT
char aam[] = { 0xb8, 0x02, 0x00, 0xd4, 0x0a, 0xf4}; //MOV AX, 0x0002    AAM     HLT

void printMem(char* start, size_t len);

int main(int argc, char* argv[])
{
    char* memory = (char*)malloc(MEMSIZE);
    memset(memory, 0, MEMSIZE);
    memcpy(memory, aam, sizeof(aam));
    
    X86EmulatorEnvironment* env = new X86EmulatorEnvironment((Address)memory, MEMSIZE);
    env->Registers()->SetRegister(SP, 0x1000);
    
    X86Emulator* emu = new X86Emulator(env);
    emu->Run();
    
    //to read 32 bits from the register, we need to set this flag, need to fix this later
    env->Overrides()->SetFlag(PREFIX_DATA32, true);
    X86EMU_DEBUG_MSG("AX is now: " << hex << env->Registers()->GetRegister(AX));
	
    X86EMU_DEBUG_MSG("Memory contents:");
    //printMem(memory, MEMSIZE);
    
    delete emu;
}

void printMem(char* start, size_t len)
{
    for(unsigned int i = 0; i < (len / 0x10); i++)
    {
        cout << hex << (unsigned long)start;
        cout << ": ";
        
        char* ptr = (char*)start;
        for(int j = 0; j < 0x10; j++)
        {
            cout << setw(2) << setfill('0');
            cout << hex << (unsigned)((*ptr++) & 0x000000ff) << " ";        //dirty, but hey...
        }
        
        ptr = (char*)start;
        cout << "\t";
        for(int j = 0; j < 0x10; j++)
        {
            char c = *ptr++;
            if(c < 0x20 || c > 0x7e)
                cout << '.';
            else
                cout << c;
        }
        
        cout << endl;
        start += 0x10;
    }
}

